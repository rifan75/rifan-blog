{
  "title": "Past, Present, and Future of React State Management",
  "publishedAt": "2021-02-02",
  "summary": "Learn about the history of state management in React and what the preferred solutions are today.",
  "image": "/static/images/react-state-management/banner.png",
  "body": {
    "raw": "\r\nReact was introduced in May 2013. Its paradigm shift was that **your UI was a function of your state**. Given some component state, React can determine what your component will look like. React is _built_ upon the idea of state. However, state has long been one of the most difficult parts of building a React application.\r\n\r\nLet's imagine state management in React as a rugged tool belt. You've used this tool belt for years, slowly adding new tools as needed. Each tool serves a very specific purpose. You don't use your hammer to screw in bolts. As a craftsman, you've learned the right time and place to use each tool.\r\n\r\n**State management with React is a rugged tool belt, but not everyone has the prior experience to know which tool to reach for.** This post will explain the past, present, and future of state management to help you make the correct decision for your team, project, or organization.\r\n\r\n## Glossary\r\n\r\nBefore we begin, it's critical you understand some of the terms commonly used. These aren't the canonical names. A few different variations of each float around, but the underlying ideas are the same:\r\n\r\n- UI State – State used for controlling interactive parts of our application (e.g. dark mode toggle, modals).\r\n- Server Cache State – State from the server, which we cache on the client-side for quick access (e.g. call an API, store the result, use it in multiple places).\r\n- Form State – The many different states of a form (e.g. loading, submitting, disabled, validation, retrying). There's also [controlled & uncontrolled form state](https://reactjs.org/docs/forms.html).\r\n- URL State – State managed by the browser (e.g. filter products, saving to query parameters, and refreshing the page to see the same products filtered)\r\n- State Machine – An explicit model of your state over time (e.g. a stoplight goes from green → yellow → red, but never green → red).\r\n\r\n## Past\r\n\r\nReact's component model helped create reusable, composable applications. Each component had its own local state. As web apps became more complex, new solutions emerged to more easily share logic between components.\r\n\r\n### Timeline\r\n\r\nTo help you understand how state management has evolved over time, here's a rough timeline of popular state management solutions in React. This list is heavily focused on UI State. This list is not comprehensive, but is enough to give context.\r\n\r\n- 2013 – Introduction\r\n- 2014 – Flux (many libraries)\r\n- 2015 – Redux\r\n- 2016 – MobX\r\n- 2018 – Context\r\n- 2019 – Hooks Introduced (+ React Query, SWR)\r\n- 2019 – Zustand\r\n- 2019 – xState\r\n- 2020 – Jotai, Recoil, Valtio\r\n- 2021 – useSelectedContext\r\n\r\nJust because an item is listed on this timeline does not mean you need to learn it. More on this later. Let's dive into the history of state management in React.\r\n\r\n### Redux\r\n\r\n[Redux](https://redux-toolkit.js.org/) was originally created as an implementation of the \"[Flux Architecture](https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/#redux-was-built-as-a-flux-architecture-implementation)\", which was a pattern first suggested by Facebook in 2014. Redux came out in 2015 and quickly became the most popular of many Flux-inspired libraries. It's ecosystem of tools and libraries encapsulated both UI state and server caching state. **Redux is still extremely popular and widely used.**\r\n\r\n<Image\r\n  alt={`Redux Growth`}\r\n  src={`/static/images/react-state-management/redux.png`}\r\n  width={1000}\r\n  height={586}\r\n/>\r\n\r\n### Server Caching State\r\n\r\nIn the early days of React, lots of state management boiled down to fetching data from APIs and caching it for use across the application. The community leaned heavily on libraries like Redux because there wasn't an easy, widely used way to manage _just_ the server cache state.\r\n\r\nWith the release of [React Hooks](https://reactjs.org/blog/2019/02/06/react-v16.8.0.html), encapsulating logic into shared hooks became much easier and accessible. Libraries like [SWR](https://swr.vercel.app/) and [React Query](https://react-query.tanstack.com/) emerged to solve this problem specifically.\r\n\r\nYou might think \"Why have a separate library just for server caching state?\". Well, **caching is hard**. Server caching state solves different problems than UI state. Here's a shortlist of some of the things these libraries handle for you:\r\n\r\n- Polling on interval\r\n- Revalidation on focus\r\n- Revalidation on network recovery\r\n- Local mutation (Optimistic UI)\r\n- Smart error retrying\r\n- Pagination and scroll position recovery\r\n\r\nDo you want to implement those yourself? _Probably not._\r\n\r\n### React Context\r\n\r\nWith [v16.3](https://reactjs.org/blog/2018/03/29/react-v-16-3.html), React Context gave us a first-party solution to share logic between components. This also prevented passing values down as props through multiple levels of nested components (i.e. \"[prop-drilling](https://kentcdodds.com/blog/prop-drilling)\").\r\n\r\nReact Context itself is [not state management](https://blog.isquaredsoftware.com/2021/01/context-redux-differences/). It can, however, [be paired with hooks](https://kentcdodds.com/blog/application-state-management-with-react) like `useReducer` to become a state management solution. This combination solved UI state for many common use cases.\r\n\r\n<Image\r\n  alt={`React Context`}\r\n  src={`/static/images/react-state-management/context.png`}\r\n  width={1000}\r\n  height={572}\r\n/>\r\n\r\n## Present\r\n\r\nIn 2021, there are various ways to handle state management in React. As the community has grown to understand the different types of state, more granular libraries have been created solving very specific use cases.\r\n\r\n### State Machines\r\n\r\nLet's consider a switch statement. If the value of `state` matches any `case`, the corresponding code runs. There's a finite set of cases. This is the most simple state machine – an explicit model of your state.\r\n\r\n```jsx\r\nswitch (state) {\r\n  case state === 'loading':\r\n    // show loading spinner\r\n    break;\r\n  case state === 'success':\r\n    // show success message\r\n    break;\r\n  default:\r\n  // show error message\r\n}\r\n```\r\n\r\n[Finite State Machines](https://xstate.js.org/docs/about/concepts.html#finite-state-machines) and [Statecharts](https://xstate.js.org/docs/about/concepts.html#statecharts) are fundamental Computer Science concepts, so this isn't anything React specific. You can turn [`useReducer`](https://reactjs.org/docs/hooks-reference.html#usereducer) into a state machine without any third-party libraries.\r\n\r\nState Machines are well-adopted everywhere, including databases, electronics, cars, and more. As state management evolved in the React ecosystem, we realized these old ideas could solve modern state management issues. State Machines are most prevalent for solving form state.\r\n\r\nWith a Finite State Machine, you have a finite number of states your application or component could be in. In practice, State Machines help you uncover bugs as you're required to think through and define edge cases. For much more information on this, I'd recommend checking out the [xState](https://xstate.js.org/docs/) docs or watching [this course](https://egghead.io/courses/introduction-to-state-machines-using-xstate). You can also [visualize entire state machines online](https://xstate.js.org/viz/).\r\n\r\n<Image\r\n  alt={`State Machines`}\r\n  src={`/static/images/react-state-management/state-machines.gif`}\r\n  width={800}\r\n  height={277}\r\n/>\r\n\r\n### Zustand, Recoil, Jotai, Valtio, Oh My!\r\n\r\nWhy do so many different libraries for React state management even exist?\r\n\r\nLet's consider Figma (or any other design tool). You have a toolbar of controls that affect other elements outside of its \"local\" state, or where the component is rendered.\r\n\r\n<Image\r\n  alt={`Figma`}\r\n  src={`/static/images/react-state-management/figma.png`}\r\n  width={1000}\r\n  height={663}\r\n/>\r\n\r\nAs you can imagine, an application of this scale would require a complex state management solution. Performance and frame rate are critical for a good user experience here, so you want control over when & how to re-render. Unique use cases like this have led to lots of exploration in the state management space.\r\n\r\nTo summarize the differences between these libraries, let's hear from [Daishi Kato](https://twitter.com/dai_shi/status/1348257768130560008):\r\n\r\n- **Valtio** uses proxies to provide a mutation-style API\r\n- **Jotai** is optimized for \"computed values\" and async actions\r\n- **Zustand** is a very thin library specifically focused on module state\r\n- **Recoil** is an experimental library using a data-flow graph\r\n\r\nHaving complex state doesn't necessarily mean you _have_ to pull for a third-party library. You can start with React and JavaScript and see how far it takes you. If optimizing requires a state management library, you can track that metric (e.g. frame rate), measure it, and verify it solves a real problem.\r\n\r\n**Don't choose one of these libraries unless there's an obvious need.**\r\n\r\n### Immutable State\r\n\r\nAnother debate is mutable vs. immutable state. There's no right answers, just opinions. If you were doing state management with vanilla JavaScript, you'll likely have mutable state. You initialize a variable, and then later set it equal to some new value. There are [entire debates](https://overreacted.io/on-let-vs-const/) on `let` vs. `const`.\r\n\r\nImmutable state gained a lot of popularity with React. The immutable crowd argues that allowing your state management solution of choice to mutate state directly results in more bugs. The mutable crowd argues it's not worth the complexity trade-off. Direct manipulation will always be less safe than indirect manipulation. It's a tradeoff between convenience and risk, which is up to you and your team.\r\n\r\nSolutions like [Immer](https://immerjs.github.io/immer/) allow you to write mutable code but _execute_ it immutably. Fancy. The basic idea is you apply your changes to a _draft state_, which is a proxy of the _current state_. Once the mutations have completed Immer will produce the _next state_ based on the changes to the draft state.\r\n\r\n<Image\r\n  alt={`Immer Immutable State`}\r\n  src={`/static/images/react-state-management/immer.png`}\r\n  width={1000}\r\n  height={389}\r\n/>\r\n\r\n### URL State\r\n\r\nLet's say you're building an e-commerce website like Amazon. You search for React books and filter by 4+ stars. This state is persisted as query parameters and managed by the browser. When you refresh the page, you see the same list of products. You can share this URL with others and they also see the same results.\r\n\r\n<Image\r\n  alt={`Amazon URL State`}\r\n  src={`/static/images/react-state-management/amazon.png`}\r\n  width={1000}\r\n  height={732}\r\n/>\r\n\r\nAnother interesting example of this is Nomad List. We can transform the browser URL state into a function of our data. Plus, we can make human-readable URLs (which Google prefers).\r\n\r\n<Image\r\n  alt={`Nomad List URL State`}\r\n  src={`/static/images/react-state-management/nomad.png`}\r\n  width={1000}\r\n  height={676}\r\n/>\r\n\r\n### Future\r\n\r\nFor large applications, it's possible a naive Context-based state management solutions (e.g. with `useReducer`) could have issues with excessive re-rendering. When a context value changes, all components that `useContext` will re-render. This makes UI interactions feel slow and janky. If you can't visually notice it, you can [use React Dev Tools](https://brycedooley.com/debug-react-rerenders/) to investigate re-rendering.\r\n\r\nThe React team has proposed a `useSelectedContext` hook to prevent performance issues with Context at scale. This [RFC was introduced](https://github.com/reactjs/rfcs/pull/119) in July 2019 and [progress has started](https://github.com/facebook/react/pull/20646) as of January 2021 behind a feature flag. This hook allows you to select a \"slice\" of Context and only re-render when that piece changes.\r\n\r\nThere are ways to work around re-rendering performance already (e.g. `useMemo`) but a first-party solution for Context is preferred. There's also a community library [useContextSelector](https://github.com/dai-shi/use-context-selector), which takes a similar approach ([demo](https://codesandbox.io/s/usecontextselector-demo-sixdr?file=/src/App.js)). [Jotai](https://github.com/pmndrs/jotai) and [Formik 3](https://formik.org/blog/formik-3-alpha) use this under the hood. Having `useSelectedContext` as part of the React standard library will eliminate complexity and code size in external libraries, as well as provide more performant options by default.\r\n\r\nIn the longer-term future, React will automatically figure out which components to re-render (\"[auto-memoization](https://github.com/reactjs/rfcs/pull/119#issuecomment-586390430)\").\r\n\r\n## State Management Options\r\n\r\nThis is not a comprehensive list. It's also open-source, so please open a PR if you disagree or if something is wrong. In general, lean on whatever empowers your developers and team. **Happy with Redux? Stay there!**\r\n\r\n### Form State\r\n\r\n| Experience   | Learning Appetite | Project/Team Size | Solution                          |\r\n| ------------ | ----------------- | ----------------- | --------------------------------- |\r\n| Beginner     | Low               | Small             | useState                          |\r\n| Beginner     | Medium            | Medium, Small     | Form Library (Formik, Final Form) |\r\n| Beginner     | High, Medium      | Large             | Ask your tech lead                |\r\n| Intermediate | Low               | Medium, Small     | Form Library (Formik, Final Form) |\r\n| Advanced     | Medium            | Medium            | State Machines                    |\r\n| Advanced     | High              | Medium            | State Machines                    |\r\n| Advanced     | High              | Large             | State Machines                    |\r\n\r\n### UI State\r\n\r\n| Experience   | Learning Appetite | Project/Team Size | Solution                             |\r\n| ------------ | ----------------- | ----------------- | ------------------------------------ |\r\n| Beginner     | Low               | Small             | useState                             |\r\n| Beginner     | Medium            | Medium, Small     | useContext + useReducer              |\r\n| Beginner     | High, Medium      | Large             | Ask your tech lead                   |\r\n| Intermediate | Low               | Medium, Small     | Redux Toolkit                        |\r\n| Advanced     | Medium            | Medium            | useContext + useReducer              |\r\n| Advanced     | High              | Medium            | Jotai, Valtio                        |\r\n| Advanced     | High              | Large             | Recoil (or Relay if you use GraphQL) |\r\n\r\n### Server Cache State\r\n\r\nRegardless of experience or team size, both [SWR](https://swr.vercel.app/) and [React Query](https://react-query.tanstack.com/) are excellent solutions. You'll be happy with either. If you're using GraphQL, you probably already know about [Apollo](https://www.apollographql.com/).\r\n\r\n### That's all, folks!\r\n\r\nState management in React has evolved massively over the past eight years. It's one of the most difficult, nuanced parts of building large web applications. Understanding the different types of state and their trade-offs is crucial for making an informed decision. I hope this post has helped – thanks for reading.\r\n",
    "code": "var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),y=(a,e)=>{for(var n in e)r(a,n,{get:e[n],enumerable:!0})},o=(a,e,n,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!g.call(a,i)&&i!==n&&r(a,i,{get:()=>e[i],enumerable:!(s=m(e,i))||s.enumerable});return a};var b=(a,e,n)=>(n=a!=null?d(p(a)):{},o(e||!a||!a.__esModule?r(n,\"default\",{value:a,enumerable:!0}):n,a)),w=a=>o(r({},\"__esModule\",{value:!0}),a);var l=f((I,c)=>{c.exports=_jsx_runtime});var R={};y(R,{default:()=>x,frontmatter:()=>v});var t=b(l()),v={title:\"Past, Present, and Future of React State Management\",publishedAt:\"2021-02-02\",summary:\"Learn about the history of state management in React and what the preferred solutions are today.\",image:\"/static/images/react-state-management/banner.png\"};function h(a){let e=Object.assign({p:\"p\",strong:\"strong\",em:\"em\",h2:\"h2\",a:\"a\",span:\"span\",ul:\"ul\",li:\"li\",h3:\"h3\",code:\"code\",pre:\"pre\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\"},a.components),{Image:n}=e;return n||N(\"Image\",!0,\"49:1-54:3\"),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"React was introduced in May 2013. Its paradigm shift was that \",(0,t.jsx)(e.strong,{children:\"your UI was a function of your state\"}),\". Given some component state, React can determine what your component will look like. React is \",(0,t.jsx)(e.em,{children:\"built\"}),\" upon the idea of state. However, state has long been one of the most difficult parts of building a React application.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Let's imagine state management in React as a rugged tool belt. You've used this tool belt for years, slowly adding new tools as needed. Each tool serves a very specific purpose. You don't use your hammer to screw in bolts. As a craftsman, you've learned the right time and place to use each tool.\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"State management with React is a rugged tool belt, but not everyone has the prior experience to know which tool to reach for.\"}),\" This post will explain the past, present, and future of state management to help you make the correct decision for your team, project, or organization.\"]}),`\n`,(0,t.jsxs)(e.h2,{id:\"glossary\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#glossary\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Glossary\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Before we begin, it's critical you understand some of the terms commonly used. These aren't the canonical names. A few different variations of each float around, but the underlying ideas are the same:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"UI State \\u2013 State used for controlling interactive parts of our application (e.g. dark mode toggle, modals).\"}),`\n`,(0,t.jsx)(e.li,{children:\"Server Cache State \\u2013 State from the server, which we cache on the client-side for quick access (e.g. call an API, store the result, use it in multiple places).\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Form State \\u2013 The many different states of a form (e.g. loading, submitting, disabled, validation, retrying). There's also \",(0,t.jsx)(e.a,{href:\"https://reactjs.org/docs/forms.html\",children:\"controlled & uncontrolled form state\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"URL State \\u2013 State managed by the browser (e.g. filter products, saving to query parameters, and refreshing the page to see the same products filtered)\"}),`\n`,(0,t.jsx)(e.li,{children:\"State Machine \\u2013 An explicit model of your state over time (e.g. a stoplight goes from green \\u2192 yellow \\u2192 red, but never green \\u2192 red).\"}),`\n`]}),`\n`,(0,t.jsxs)(e.h2,{id:\"past\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#past\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Past\"]}),`\n`,(0,t.jsx)(e.p,{children:\"React's component model helped create reusable, composable applications. Each component had its own local state. As web apps became more complex, new solutions emerged to more easily share logic between components.\"}),`\n`,(0,t.jsxs)(e.h3,{id:\"timeline\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#timeline\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Timeline\"]}),`\n`,(0,t.jsx)(e.p,{children:\"To help you understand how state management has evolved over time, here's a rough timeline of popular state management solutions in React. This list is heavily focused on UI State. This list is not comprehensive, but is enough to give context.\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"2013 \\u2013 Introduction\"}),`\n`,(0,t.jsx)(e.li,{children:\"2014 \\u2013 Flux (many libraries)\"}),`\n`,(0,t.jsx)(e.li,{children:\"2015 \\u2013 Redux\"}),`\n`,(0,t.jsx)(e.li,{children:\"2016 \\u2013 MobX\"}),`\n`,(0,t.jsx)(e.li,{children:\"2018 \\u2013 Context\"}),`\n`,(0,t.jsx)(e.li,{children:\"2019 \\u2013 Hooks Introduced (+ React Query, SWR)\"}),`\n`,(0,t.jsx)(e.li,{children:\"2019 \\u2013 Zustand\"}),`\n`,(0,t.jsx)(e.li,{children:\"2019 \\u2013 xState\"}),`\n`,(0,t.jsx)(e.li,{children:\"2020 \\u2013 Jotai, Recoil, Valtio\"}),`\n`,(0,t.jsx)(e.li,{children:\"2021 \\u2013 useSelectedContext\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Just because an item is listed on this timeline does not mean you need to learn it. More on this later. Let's dive into the history of state management in React.\"}),`\n`,(0,t.jsxs)(e.h3,{id:\"redux\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#redux\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Redux\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://redux-toolkit.js.org/\",children:\"Redux\"}),' was originally created as an implementation of the \"',(0,t.jsx)(e.a,{href:\"https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/#redux-was-built-as-a-flux-architecture-implementation\",children:\"Flux Architecture\"}),`\", which was a pattern first suggested by Facebook in 2014. Redux came out in 2015 and quickly became the most popular of many Flux-inspired libraries. It's ecosystem of tools and libraries encapsulated both UI state and server caching state. `,(0,t.jsx)(e.strong,{children:\"Redux is still extremely popular and widely used.\"})]}),`\n`,(0,t.jsx)(n,{alt:\"Redux Growth\",src:\"/static/images/react-state-management/redux.png\",width:1e3,height:586}),`\n`,(0,t.jsxs)(e.h3,{id:\"server-caching-state\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#server-caching-state\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Server Caching State\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the early days of React, lots of state management boiled down to fetching data from APIs and caching it for use across the application. The community leaned heavily on libraries like Redux because there wasn't an easy, widely used way to manage \",(0,t.jsx)(e.em,{children:\"just\"}),\" the server cache state.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"With the release of \",(0,t.jsx)(e.a,{href:\"https://reactjs.org/blog/2019/02/06/react-v16.8.0.html\",children:\"React Hooks\"}),\", encapsulating logic into shared hooks became much easier and accessible. Libraries like \",(0,t.jsx)(e.a,{href:\"https://swr.vercel.app/\",children:\"SWR\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://react-query.tanstack.com/\",children:\"React Query\"}),\" emerged to solve this problem specifically.\"]}),`\n`,(0,t.jsxs)(e.p,{children:['You might think \"Why have a separate library just for server caching state?\". Well, ',(0,t.jsx)(e.strong,{children:\"caching is hard\"}),\". Server caching state solves different problems than UI state. Here's a shortlist of some of the things these libraries handle for you:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Polling on interval\"}),`\n`,(0,t.jsx)(e.li,{children:\"Revalidation on focus\"}),`\n`,(0,t.jsx)(e.li,{children:\"Revalidation on network recovery\"}),`\n`,(0,t.jsx)(e.li,{children:\"Local mutation (Optimistic UI)\"}),`\n`,(0,t.jsx)(e.li,{children:\"Smart error retrying\"}),`\n`,(0,t.jsx)(e.li,{children:\"Pagination and scroll position recovery\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Do you want to implement those yourself? \",(0,t.jsx)(e.em,{children:\"Probably not.\"})]}),`\n`,(0,t.jsxs)(e.h3,{id:\"react-context\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#react-context\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"React Context\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"With \",(0,t.jsx)(e.a,{href:\"https://reactjs.org/blog/2018/03/29/react-v-16-3.html\",children:\"v16.3\"}),', React Context gave us a first-party solution to share logic between components. This also prevented passing values down as props through multiple levels of nested components (i.e. \"',(0,t.jsx)(e.a,{href:\"https://kentcdodds.com/blog/prop-drilling\",children:\"prop-drilling\"}),'\").']}),`\n`,(0,t.jsxs)(e.p,{children:[\"React Context itself is \",(0,t.jsx)(e.a,{href:\"https://blog.isquaredsoftware.com/2021/01/context-redux-differences/\",children:\"not state management\"}),\". It can, however, \",(0,t.jsx)(e.a,{href:\"https://kentcdodds.com/blog/application-state-management-with-react\",children:\"be paired with hooks\"}),\" like \",(0,t.jsx)(e.code,{children:\"useReducer\"}),\" to become a state management solution. This combination solved UI state for many common use cases.\"]}),`\n`,(0,t.jsx)(n,{alt:\"React Context\",src:\"/static/images/react-state-management/context.png\",width:1e3,height:572}),`\n`,(0,t.jsxs)(e.h2,{id:\"present\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#present\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Present\"]}),`\n`,(0,t.jsx)(e.p,{children:\"In 2021, there are various ways to handle state management in React. As the community has grown to understand the different types of state, more granular libraries have been created solving very specific use cases.\"}),`\n`,(0,t.jsxs)(e.h3,{id:\"state-machines\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#state-machines\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"State Machines\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's consider a switch statement. If the value of \",(0,t.jsx)(e.code,{children:\"state\"}),\" matches any \",(0,t.jsx)(e.code,{children:\"case\"}),\", the corresponding code runs. There's a finite set of cases. This is the most simple state machine \\u2013 an explicit model of your state.\"]}),`\n`,(0,t.jsx)(e.pre,{className:\"language-jsx\",children:(0,t.jsxs)(e.code,{className:\"language-jsx code-highlight\",children:[(0,t.jsxs)(e.span,{className:\"code-line\",children:[(0,t.jsx)(e.span,{className:\"token keyword control-flow\",children:\"switch\"}),\" \",(0,t.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),\"state\",(0,t.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,t.jsx)(e.span,{className:\"token punctuation\",children:\"{\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"  \",(0,t.jsx)(e.span,{className:\"token keyword\",children:\"case\"}),\" state \",(0,t.jsx)(e.span,{className:\"token operator\",children:\"===\"}),\" \",(0,t.jsx)(e.span,{className:\"token string\",children:\"'loading'\"}),(0,t.jsx)(e.span,{className:\"token operator\",children:\":\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"    \",(0,t.jsx)(e.span,{className:\"token comment\",children:\"// show loading spinner\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"    \",(0,t.jsx)(e.span,{className:\"token keyword control-flow\",children:\"break\"}),(0,t.jsx)(e.span,{className:\"token punctuation\",children:\";\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"  \",(0,t.jsx)(e.span,{className:\"token keyword\",children:\"case\"}),\" state \",(0,t.jsx)(e.span,{className:\"token operator\",children:\"===\"}),\" \",(0,t.jsx)(e.span,{className:\"token string\",children:\"'success'\"}),(0,t.jsx)(e.span,{className:\"token operator\",children:\":\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"    \",(0,t.jsx)(e.span,{className:\"token comment\",children:\"// show success message\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"    \",(0,t.jsx)(e.span,{className:\"token keyword control-flow\",children:\"break\"}),(0,t.jsx)(e.span,{className:\"token punctuation\",children:\";\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"  \",(0,t.jsx)(e.span,{className:\"token keyword module\",children:\"default\"}),(0,t.jsx)(e.span,{className:\"token operator\",children:\":\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[\"  \",(0,t.jsx)(e.span,{className:\"token comment\",children:\"// show error message\"}),`\\r\n`]}),(0,t.jsxs)(e.span,{className:\"code-line\",children:[(0,t.jsx)(e.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})]})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:\"https://xstate.js.org/docs/about/concepts.html#finite-state-machines\",children:\"Finite State Machines\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://xstate.js.org/docs/about/concepts.html#statecharts\",children:\"Statecharts\"}),\" are fundamental Computer Science concepts, so this isn't anything React specific. You can turn \",(0,t.jsx)(e.a,{href:\"https://reactjs.org/docs/hooks-reference.html#usereducer\",children:(0,t.jsx)(e.code,{children:\"useReducer\"})}),\" into a state machine without any third-party libraries.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"State Machines are well-adopted everywhere, including databases, electronics, cars, and more. As state management evolved in the React ecosystem, we realized these old ideas could solve modern state management issues. State Machines are most prevalent for solving form state.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"With a Finite State Machine, you have a finite number of states your application or component could be in. In practice, State Machines help you uncover bugs as you're required to think through and define edge cases. For much more information on this, I'd recommend checking out the \",(0,t.jsx)(e.a,{href:\"https://xstate.js.org/docs/\",children:\"xState\"}),\" docs or watching \",(0,t.jsx)(e.a,{href:\"https://egghead.io/courses/introduction-to-state-machines-using-xstate\",children:\"this course\"}),\". You can also \",(0,t.jsx)(e.a,{href:\"https://xstate.js.org/viz/\",children:\"visualize entire state machines online\"}),\".\"]}),`\n`,(0,t.jsx)(n,{alt:\"State Machines\",src:\"/static/images/react-state-management/state-machines.gif\",width:800,height:277}),`\n`,(0,t.jsxs)(e.h3,{id:\"zustand-recoil-jotai-valtio-oh-my\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#zustand-recoil-jotai-valtio-oh-my\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Zustand, Recoil, Jotai, Valtio, Oh My!\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Why do so many different libraries for React state management even exist?\"}),`\n`,(0,t.jsx)(e.p,{children:`Let's consider Figma (or any other design tool). You have a toolbar of controls that affect other elements outside of its \"local\" state, or where the component is rendered.`}),`\n`,(0,t.jsx)(n,{alt:\"Figma\",src:\"/static/images/react-state-management/figma.png\",width:1e3,height:663}),`\n`,(0,t.jsx)(e.p,{children:\"As you can imagine, an application of this scale would require a complex state management solution. Performance and frame rate are critical for a good user experience here, so you want control over when & how to re-render. Unique use cases like this have led to lots of exploration in the state management space.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"To summarize the differences between these libraries, let's hear from \",(0,t.jsx)(e.a,{href:\"https://twitter.com/dai_shi/status/1348257768130560008\",children:\"Daishi Kato\"}),\":\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Valtio\"}),\" uses proxies to provide a mutation-style API\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Jotai\"}),' is optimized for \"computed values\" and async actions']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Zustand\"}),\" is a very thin library specifically focused on module state\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Recoil\"}),\" is an experimental library using a data-flow graph\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Having complex state doesn't necessarily mean you \",(0,t.jsx)(e.em,{children:\"have\"}),\" to pull for a third-party library. You can start with React and JavaScript and see how far it takes you. If optimizing requires a state management library, you can track that metric (e.g. frame rate), measure it, and verify it solves a real problem.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"Don't choose one of these libraries unless there's an obvious need.\"})}),`\n`,(0,t.jsxs)(e.h3,{id:\"immutable-state\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#immutable-state\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Immutable State\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Another debate is mutable vs. immutable state. There's no right answers, just opinions. If you were doing state management with vanilla JavaScript, you'll likely have mutable state. You initialize a variable, and then later set it equal to some new value. There are \",(0,t.jsx)(e.a,{href:\"https://overreacted.io/on-let-vs-const/\",children:\"entire debates\"}),\" on \",(0,t.jsx)(e.code,{children:\"let\"}),\" vs. \",(0,t.jsx)(e.code,{children:\"const\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Immutable state gained a lot of popularity with React. The immutable crowd argues that allowing your state management solution of choice to mutate state directly results in more bugs. The mutable crowd argues it's not worth the complexity trade-off. Direct manipulation will always be less safe than indirect manipulation. It's a tradeoff between convenience and risk, which is up to you and your team.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Solutions like \",(0,t.jsx)(e.a,{href:\"https://immerjs.github.io/immer/\",children:\"Immer\"}),\" allow you to write mutable code but \",(0,t.jsx)(e.em,{children:\"execute\"}),\" it immutably. Fancy. The basic idea is you apply your changes to a \",(0,t.jsx)(e.em,{children:\"draft state\"}),\", which is a proxy of the \",(0,t.jsx)(e.em,{children:\"current state\"}),\". Once the mutations have completed Immer will produce the \",(0,t.jsx)(e.em,{children:\"next state\"}),\" based on the changes to the draft state.\"]}),`\n`,(0,t.jsx)(n,{alt:\"Immer Immutable State\",src:\"/static/images/react-state-management/immer.png\",width:1e3,height:389}),`\n`,(0,t.jsxs)(e.h3,{id:\"url-state\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#url-state\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"URL State\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Let's say you're building an e-commerce website like Amazon. You search for React books and filter by 4+ stars. This state is persisted as query parameters and managed by the browser. When you refresh the page, you see the same list of products. You can share this URL with others and they also see the same results.\"}),`\n`,(0,t.jsx)(n,{alt:\"Amazon URL State\",src:\"/static/images/react-state-management/amazon.png\",width:1e3,height:732}),`\n`,(0,t.jsx)(e.p,{children:\"Another interesting example of this is Nomad List. We can transform the browser URL state into a function of our data. Plus, we can make human-readable URLs (which Google prefers).\"}),`\n`,(0,t.jsx)(n,{alt:\"Nomad List URL State\",src:\"/static/images/react-state-management/nomad.png\",width:1e3,height:676}),`\n`,(0,t.jsxs)(e.h3,{id:\"future\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#future\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Future\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"For large applications, it's possible a naive Context-based state management solutions (e.g. with \",(0,t.jsx)(e.code,{children:\"useReducer\"}),\") could have issues with excessive re-rendering. When a context value changes, all components that \",(0,t.jsx)(e.code,{children:\"useContext\"}),\" will re-render. This makes UI interactions feel slow and janky. If you can't visually notice it, you can \",(0,t.jsx)(e.a,{href:\"https://brycedooley.com/debug-react-rerenders/\",children:\"use React Dev Tools\"}),\" to investigate re-rendering.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The React team has proposed a \",(0,t.jsx)(e.code,{children:\"useSelectedContext\"}),\" hook to prevent performance issues with Context at scale. This \",(0,t.jsx)(e.a,{href:\"https://github.com/reactjs/rfcs/pull/119\",children:\"RFC was introduced\"}),\" in July 2019 and \",(0,t.jsx)(e.a,{href:\"https://github.com/facebook/react/pull/20646\",children:\"progress has started\"}),' as of January 2021 behind a feature flag. This hook allows you to select a \"slice\" of Context and only re-render when that piece changes.']}),`\n`,(0,t.jsxs)(e.p,{children:[\"There are ways to work around re-rendering performance already (e.g. \",(0,t.jsx)(e.code,{children:\"useMemo\"}),\") but a first-party solution for Context is preferred. There's also a community library \",(0,t.jsx)(e.a,{href:\"https://github.com/dai-shi/use-context-selector\",children:\"useContextSelector\"}),\", which takes a similar approach (\",(0,t.jsx)(e.a,{href:\"https://codesandbox.io/s/usecontextselector-demo-sixdr?file=/src/App.js\",children:\"demo\"}),\"). \",(0,t.jsx)(e.a,{href:\"https://github.com/pmndrs/jotai\",children:\"Jotai\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://formik.org/blog/formik-3-alpha\",children:\"Formik 3\"}),\" use this under the hood. Having \",(0,t.jsx)(e.code,{children:\"useSelectedContext\"}),\" as part of the React standard library will eliminate complexity and code size in external libraries, as well as provide more performant options by default.\"]}),`\n`,(0,t.jsxs)(e.p,{children:['In the longer-term future, React will automatically figure out which components to re-render (\"',(0,t.jsx)(e.a,{href:\"https://github.com/reactjs/rfcs/pull/119#issuecomment-586390430\",children:\"auto-memoization\"}),'\").']}),`\n`,(0,t.jsxs)(e.h2,{id:\"state-management-options\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#state-management-options\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"State Management Options\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This is not a comprehensive list. It's also open-source, so please open a PR if you disagree or if something is wrong. In general, lean on whatever empowers your developers and team. \",(0,t.jsx)(e.strong,{children:\"Happy with Redux? Stay there!\"})]}),`\n`,(0,t.jsxs)(e.h3,{id:\"form-state\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#form-state\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Form State\"]}),`\n`,(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Experience\"}),(0,t.jsx)(e.th,{children:\"Learning Appetite\"}),(0,t.jsx)(e.th,{children:\"Project/Team Size\"}),(0,t.jsx)(e.th,{children:\"Solution\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Beginner\"}),(0,t.jsx)(e.td,{children:\"Low\"}),(0,t.jsx)(e.td,{children:\"Small\"}),(0,t.jsx)(e.td,{children:\"useState\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Beginner\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"Medium, Small\"}),(0,t.jsx)(e.td,{children:\"Form Library (Formik, Final Form)\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Beginner\"}),(0,t.jsx)(e.td,{children:\"High, Medium\"}),(0,t.jsx)(e.td,{children:\"Large\"}),(0,t.jsx)(e.td,{children:\"Ask your tech lead\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Intermediate\"}),(0,t.jsx)(e.td,{children:\"Low\"}),(0,t.jsx)(e.td,{children:\"Medium, Small\"}),(0,t.jsx)(e.td,{children:\"Form Library (Formik, Final Form)\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Advanced\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"State Machines\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Advanced\"}),(0,t.jsx)(e.td,{children:\"High\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"State Machines\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Advanced\"}),(0,t.jsx)(e.td,{children:\"High\"}),(0,t.jsx)(e.td,{children:\"Large\"}),(0,t.jsx)(e.td,{children:\"State Machines\"})]})]})]}),`\n`,(0,t.jsxs)(e.h3,{id:\"ui-state\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#ui-state\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"UI State\"]}),`\n`,(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Experience\"}),(0,t.jsx)(e.th,{children:\"Learning Appetite\"}),(0,t.jsx)(e.th,{children:\"Project/Team Size\"}),(0,t.jsx)(e.th,{children:\"Solution\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Beginner\"}),(0,t.jsx)(e.td,{children:\"Low\"}),(0,t.jsx)(e.td,{children:\"Small\"}),(0,t.jsx)(e.td,{children:\"useState\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Beginner\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"Medium, Small\"}),(0,t.jsx)(e.td,{children:\"useContext + useReducer\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Beginner\"}),(0,t.jsx)(e.td,{children:\"High, Medium\"}),(0,t.jsx)(e.td,{children:\"Large\"}),(0,t.jsx)(e.td,{children:\"Ask your tech lead\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Intermediate\"}),(0,t.jsx)(e.td,{children:\"Low\"}),(0,t.jsx)(e.td,{children:\"Medium, Small\"}),(0,t.jsx)(e.td,{children:\"Redux Toolkit\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Advanced\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"useContext + useReducer\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Advanced\"}),(0,t.jsx)(e.td,{children:\"High\"}),(0,t.jsx)(e.td,{children:\"Medium\"}),(0,t.jsx)(e.td,{children:\"Jotai, Valtio\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:\"Advanced\"}),(0,t.jsx)(e.td,{children:\"High\"}),(0,t.jsx)(e.td,{children:\"Large\"}),(0,t.jsx)(e.td,{children:\"Recoil (or Relay if you use GraphQL)\"})]})]})]}),`\n`,(0,t.jsxs)(e.h3,{id:\"server-cache-state\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#server-cache-state\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"Server Cache State\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Regardless of experience or team size, both \",(0,t.jsx)(e.a,{href:\"https://swr.vercel.app/\",children:\"SWR\"}),\" and \",(0,t.jsx)(e.a,{href:\"https://react-query.tanstack.com/\",children:\"React Query\"}),\" are excellent solutions. You'll be happy with either. If you're using GraphQL, you probably already know about \",(0,t.jsx)(e.a,{href:\"https://www.apollographql.com/\",children:\"Apollo\"}),\".\"]}),`\n`,(0,t.jsxs)(e.h3,{id:\"thats-all-folks\",children:[(0,t.jsx)(e.a,{className:\"anchor\",href:\"#thats-all-folks\",children:(0,t.jsx)(e.span,{className:\"icon icon-link\"})}),\"That's all, folks!\"]}),`\n`,(0,t.jsx)(e.p,{children:\"State management in React has evolved massively over the past eight years. It's one of the most difficult, nuanced parts of building large web applications. Understanding the different types of state and their trade-offs is crucial for making an informed decision. I hope this post has helped \\u2013 thanks for reading.\"})]})}function k(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(h,a)})):h(a)}var x=k;function N(a,e,n){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+a+\"` to be defined: you likely forgot to import, pass, or provide it.\"+(n?\"\\nIt\\u2019s referenced in your code at `\"+n+\"` in `D:\\\\Linux_Share\\\\reactapp\\\\rifan-blog\\\\data\\\\blog\\\\_mdx_bundler_entry_point-f0d7b349-1069-4178-b704-641bfa952c1c.mdx`\":\"\"))}return w(R);})();\n;return Component;"
  },
  "_id": "blog/react-state-management.mdx",
  "_raw": {
    "sourceFilePath": "blog/react-state-management.mdx",
    "sourceFileName": "react-state-management.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/react-state-management"
  },
  "type": "Blog",
  "readingTime": {
    "text": "11 min read",
    "minutes": 10.22,
    "time": 613200,
    "words": 2044
  },
  "wordCount": 2046,
  "tweetIds": [],
  "slug": "react-state-management"
}